// 小红在有n块积木，每块长度为2，可以用来搭建一个图案。为了保证搭建的顺利进行，小红将场地从左到右标记为1~k。小红会首先寻找一个位置放下第一块积木，然后第二块积木放在第一块的上面，以此类推。小红要求，每块积木必须与上一块积木恰好有一个位置重合。任何按照这种方法搭建出来的图案都叫做合法的。

// 我们用无序对(x,y)表示一个积木，那么当k=4时，序列{(1,2),(2,3),(3,4)}和{(2,3),(3,4),(2,3)}都是合法的，而序列{(1,2),(3,4)}，{(3,4),(4,5)}和序列{(1,2),(1,2)}都不是合法的。

// 请问n块积木有多少种合法的摆法？两种摆法不同当且仅当存在至少一块积木的位置不同。



#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, k;
    cin >> n >> k;

    vector<vector<int>> dp(n, vector<int> vec(k, 0));

    for (int i = 3; i <= k; i++) {
        dp[1][i] = i - 1;
    }

    for (int i = 3; i <= k; i++) {
        dp[2][i] = dp[0][i] + i - 3;
    }

    for (int j = 1; j <= n; j++) {
        dp[j][3] = 2;
    }

    for (int j = 3; j <= n; j++) {
        for (int i = 4; i <= k; i++) {
            dp[j][i] = dp[j-1][i-1] + dp[j-1][i];
        }
    }
    cout << dp[n][k] << endl;
    return 0;
}